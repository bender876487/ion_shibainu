var c = Object.defineProperty;
var f = (r, i, t) => i in r ? c(r, i, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[i] = t;
var a = (r, i, t) => (f(r, typeof i != "symbol" ? i + "" : i, t), t);
import { B as g, d as p } from "./comparator.9bec0307.mjs";
function m(r) {
  return {
    value: r,
    nextSibling: null,
    firstChild: null
  };
}
function u(r) {
  return r ? [
    r.value,
    ...u(r.firstChild),
    ...u(r.nextSibling)
  ] : [];
}
function s(r, i, t) {
  return !r || !i ? r || i : t(r.value, i.value) < 0 ? s(i, r, t) : (i.nextSibling = r.firstChild, r.firstChild = i, r);
}
function d(r, i) {
  let t = r, n = null, e = null, l = null;
  for (; t; )
    e = t, t = e.nextSibling, e.nextSibling = null, l = t, l && (t = l.nextSibling, l.nextSibling = null), e = s(e, l, i), e.nextSibling = n, n = e;
  let o = null;
  for (; n; )
    o = n, n = o.nextSibling, o = s(o, t, i), t = o;
  return t;
}
class h extends g {
  constructor({ comparator: t = p } = {}) {
    super("PairingHeap");
    a(this, "comparator");
    a(this, "root", null);
    a(this, "_length", 0);
    this.comparator = t;
  }
  static from(t, n = {}) {
    const e = new h(n);
    for (let l = 0, o = t.length; l < o; ++l)
      e.push(t[l]);
    return e;
  }
  clear() {
    this._length = 0, this.root = null;
  }
  get length() {
    return this._length;
  }
  push(t) {
    this.root = s(this.root, m(t), this.comparator), this._length += 1;
  }
  top() {
    if (!this.root)
      throw new Error("invalid operation: top() called for empty PairingHeap");
    return this.root.value;
  }
  pop() {
    if (!this.root)
      throw new Error("invalid operation: pop() called for empty PairingHeap");
    const t = this.root.value;
    return this.root = d(this.root.firstChild, this.comparator), this._length -= 1, t;
  }
  merge(t) {
    if (t instanceof h && this.comparator === t.comparator) {
      this.root = s(this.root, t.root, this.comparator), this._length += t.length, t.clear();
      return;
    }
    for (let n = 0, e = t.toArray(), l = e.length; n < l; ++n)
      this.push(e[n]);
    t.clear();
  }
  toArray() {
    return u(this.root).sort(this.comparator);
  }
  isEmpty() {
    return !this.root;
  }
}
export {
  h as default
};
//# sourceMappingURL=PairingHeap.mjs.map
