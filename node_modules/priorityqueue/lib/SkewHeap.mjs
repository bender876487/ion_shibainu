var p = Object.defineProperty;
var c = (r, o, t) => o in r ? p(r, o, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[o] = t;
var l = (r, o, t) => (c(r, typeof o != "symbol" ? o + "" : o, t), t);
import { B as f, d as g } from "./comparator.9bec0307.mjs";
function m(r) {
  return {
    value: r,
    left: null,
    right: null
  };
}
function h(r) {
  return r ? [...h(r.left), r.value, ...h(r.right)] : [];
}
function n(r, o, t) {
  if (!r || !o)
    return r || o;
  if (t(r.value, o.value) < 0)
    return n(o, r, t);
  r.right = n(r.right, o, t);
  const e = r.right;
  return r.right = r.left, r.left = e, r;
}
class u extends f {
  constructor({ comparator: t = g } = {}) {
    super("SkewHeap");
    l(this, "comparator");
    l(this, "root", null);
    l(this, "_length", 0);
    this.comparator = t;
  }
  static from(t, e = {}) {
    const i = new u(e);
    for (let s = 0, a = t.length; s < a; ++s)
      i.push(t[s]);
    return i;
  }
  clear() {
    this._length = 0, this.root = null;
  }
  get length() {
    return this._length;
  }
  push(t) {
    this.root = n(this.root, m(t), this.comparator), this._length += 1;
  }
  top() {
    if (!this.root)
      throw new Error("invalid operation: top() called for empty SkewHeap");
    return this.root.value;
  }
  pop() {
    if (!this.root)
      throw new Error("invalid operation: pop() called for empty SkewHeap");
    const t = this.root.value;
    return this.root = n(this.root.right, this.root.left, this.comparator), this._length -= 1, t;
  }
  merge(t) {
    if (t instanceof u && this.comparator === t.comparator) {
      this.root = n(this.root, t.root, this.comparator), this._length += t.length, t.clear();
      return;
    }
    for (let e = 0, i = t.toArray(), s = i.length; e < s; ++e)
      this.push(i[e]);
    t.clear();
  }
  toArray() {
    return h(this.root).sort(this.comparator);
  }
  isEmpty() {
    return !this.root;
  }
}
export {
  u as default
};
//# sourceMappingURL=SkewHeap.mjs.map
